/*
10未満の自然数のうち, 3 もしくは 5 の倍数になっているものは 3, 5, 6, 9 の4つがあり, これらの合計は 23 になる.
同じようにして, n 未満の 3 か 5 の倍数になっている数字の合計を求めよ.
処理には再帰を使用すること.
*/
pub fn p001(end: u64) -> u64 {
    (1..end).fold(0, |sum, x| if x % 3 == 0 || x % 5 == 0 { sum + x } else { sum })
}

/*
フィボナッチ数列の項は前の2つの項の和である. 最初の2項を 1, 2 とすれば, 最初の10項は以下の通りである.

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

数列の項の値が400万以下のとき, 値が偶数の項の総和を求めよ.
*/
pub fn p002(end: u64) -> u64 {
    let mut sum = 0;
    let mut a = 1;
    let mut b = 2;
    while b < end {
        if b % 2 == 0 {
            sum += b;
        }
        let c = a + b;
        a = b;
        b = c;
    }
    sum
}

/*
13195 の素因数は 5, 7, 13, 29 である.
600851475143 の素因数のうち最大のものを求めよ.
*/
pub fn p003(num: u64) -> u64 {
    let mut n = num;
    let mut i = 2;
    while i * i <= n {
        while n % i == 0 {
            n /= i;
        }
        i += 1;
    }
    n
}

/*
左右どちらから読んでも同じ値になる数を回文数という. 2桁の数の積で表される回文数のうち, 最大のものは 9009 = 91 × 99 である.
では, 3桁の数の積で表される回文数の最大値を求めよ.
*/
pub fn p004() -> u64 {
    let mut max = 0;
    for i in 100..1000 {
        for j in i..1000 {
            let n = i * j;
            if n > max && is_palindrome(n) {
                max = n;
            }
        }
    }
    max
}

fn is_palindrome(n: u64) -> bool {
    let s = n.to_string();
    let r = s.chars().rev().collect::<String>();
    s == r
}

/*
2520 は 1 から 10 の数字の全ての整数で割り切れる数字であり, そのような数字の中では最小の値である.
では, 1 から 20 までの整数全てで割り切れる数字の中で最小の正の数はいくらになるか.
*/
pub fn p005() -> u64 {
    use num::integer::lcm;
    let mut n = 1;
    for i in 1..21 {
        n = lcm(n, i);
    }
    n
}

/*
最初の10個の自然数について, その二乗の和は,

12 + 22 + ... + 102 = 385

最初の10個の自然数について, その和の二乗は,

(1 + 2 + ... + 10)2 = 3025

これらの数の差は 3025 - 385 = 2640 となる.
同様にして, 最初の100個の自然数について二乗の和と和の二乗の差を求めよ.
*/
pub fn p006(end: u64) -> u64 {
    let sum_of_squares = (1..end + 1).map(|x| x * x).sum::<u64>();
    let square_of_sum = (1..end + 1).sum::<u64>().pow(2);
    square_of_sum - sum_of_squares
}

/*
素数を小さい方から6つ並べると 2, 3, 5, 7, 11, 13 であり, 6番目の素数は 13 である.
10 001 番目の素数を求めよ.
*/
pub fn p007(n: usize) -> u64 {
    let mut count = 0;
    let mut i = 2;
    while count < n {
        if is_prime(i) {
            count += 1;
        }
        i += 1;
    }
    i - 1
}

fn is_prime(n: u64) -> bool {
    if n < 2 {
        return false;
    }
    let mut i = 2;
    while i * i <= n {
        if n % i == 0 {
            return false;
        }
        i += 1;
    }
    true
}

/*
次の1000桁の数字のうち, 隣接する4つの数字の総乗の中で, 最大となる値は, 9 × 9 × 8 × 9 = 5832である.

73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450

この1000桁の数字から13個の連続する数字を取り出して, それらの総乗を計算する. では、それら総乗のうち、最大となる値はいくらか.
EX) 6桁の数123789から5個の連続する数字を取り出す場合, 1*2*3*7*8と2*3*7*8*9の二通りとなり, 後者の2*3*7*8*9=3024が最大の総乗となる.
*/
pub fn p008() -> u64 {
    let s = "73167176531330624919225119674426574742355349194934\
    96983520312774506326239578318016984801869478851843\
    85861560789112949495459501737958331952853208805511\
    12540698747158523863050715693290963295227443043557\
    66896648950445244523161731856403098711121722383113\
    62229893423380308135336276614282806444486645238749\
    30358907296290491560440772390713810515859307960866\
    70172427121883998797908792274921901699720888093776\
    65727333001053367881220235421809751254540594752243\
    52584907711670556013604839586446706324415722155397\
    53697817977846174064955149290862569321978468622482\
    83972241375657056057490261407972968652414535100474\
    82166370484403199890008895243450658541227588666881\
    16427171479924442928230863465674813919123162824586\
    17866458359124566529476545682848912883142607690042\
    24219022671055626321111109370544217506941658960408\
    07198403850962455444362981230987879927244284909188\
    84580156166097919133875499200524063689912560717606\
    05886116467109405077541002256983155200055935729725\
    71636269561882670428252483600823257530420752963450";
    let digits = s.chars().map(|c| c.to_digit(10).unwrap() as u64).collect::<Vec<_>>();
    let mut max = 0;
    for i in 0..digits.len() - 13 {
        let mut n: u64 = 1;
        for j in i..i + 13 {
            n *= digits[j];
        }
        if n > max {
            max = n;
        }
    }
    max
}

/*
ピタゴラス数(ピタゴラスの定理を満たす自然数)とは a < b < c で以下の式を満たす数の組である.

a^2 + b^2 = c^2

例えば, 3^2 + 4^2 = 9 + 16 = 25 = 5^2 である.
a + b + c = 1000 となるピタゴラスの三つ組が一つだけ存在する.
これらの積 abc を計算しなさい.
*/
pub fn p009() -> u64 {
    for a in 1..1000 {
        for b in a + 1..1000 - a {
            let c = 1000 - a - b;
            if a * a + b * b == c * c {
                return a * b * c;
            }
        }
    }
    0
}

/*
10以下の素数の和は 2 + 3 + 5 + 7 = 17 である.
200万以下の全ての素数の和を求めよ.
*/

pub fn p010() -> u64 {
    let mut sum = 0;
    for i in 2..2000000 {
        if is_prime(i) {
            sum += i;
        }
    }
    sum
}